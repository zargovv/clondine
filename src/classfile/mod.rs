mod cpinfo;

use std::{fmt::Debug, io, rc::Rc};

use cpinfo::CpInfo;
use macros::Cpref;

use crate::{
  bitfield::bitfield,
  deread::{ByteSeq, Deread, Dereader},
};

const MAGIC: u32 = 0xcafe_babe;

bitfield! {
  #[allow(dead_code)]
  ClassFileAccessFlags: u16 {
    #[doc = "Declared public; may be accessed from outside its package."]
    PUBLIC = 0x0001,
    #[doc = "Declared final; no subclasses allowed."]
    FINAL = 0x0010,
    #[doc = "Treat superclass methods specially when invoked by the invokespecial instruction."]
    SUPER = 0x0020,
    #[doc = "Is an interface, not a class."]
    INTERFACE = 0x0200,
    #[doc = "Declared abstract; must not be instantiated."]
    ABSTRACT = 0x0400,
    #[doc = "Declared synthetic; not present in the source code."]
    SYNTHETIC = 0x1000,
    #[doc = "Declared as an annotation type."]
    ANNOTATION = 0x2000,
    #[doc = "Declared as an enum type."]
    ENUM = 0x4000,
  }

  #[allow(dead_code)]
  MethodInfoAccessFlags: u16 {
    #[doc = "Declared public; may be accessed from outside its package."]
    PUBLIC = 0x0001,
    #[doc = "Declared private; accessible only within the defining class."]
    PRIVATE = 0x0002,
    #[doc = "Declared protected; may be accessed within subclasses."]
    PROTECTED = 0x0004,
    #[doc = "Declared static."]
    STATIC = 0x0008,
    #[doc = "Declared final; must not be overridden (ยง5.4.5)."]
    FINAL = 0x0010,
    #[doc = "Declared synchronized; invocation is wrapped by a monitor use."]
    SYNCHRONIZED = 0x0020,
    #[doc = "A bridge method, generated by the compiler."]
    BRIDGE = 0x0040,
    #[doc = "Declared with variable number of arguments."]
    VARARGS = 0x0080,
    #[doc = "Declared native; implemented in a language other than Java."]
    NATIVE = 0x0100,
    #[doc = "Declared abstract; no implementation is provided."]
    ABSTRACT = 0x0400,
    #[doc = "Declared strictfp; floating-point mode is FP-strict."]
    STRICT = 0x0800,
    #[doc = "Declared synthetic; not present in the source code."]
    SYNTHETIC = 0x1000,
  }

  #[allow(dead_code)]
  FieldInfoAccessFlags: u16 {
    #[doc = "Declared public; may be accessed from outside its package."]
    PUBLIC = 0x0001,
    #[doc = "Declared private; usable only within the defining class."]
    PRIVATE = 0x0002,
    #[doc = "Declared protected; may be accessed within subclasses."]
    PROTECTED = 0x0004,
    #[doc = "Declared static."]
    STATIC = 0x0008,
    #[doc = "Declared final; never directly assigned to after object construction (JLS ยง17.5)."]
    FINAL = 0x0010,
    #[doc = "Declared volatile; cannot be cached."]
    VOLATILE = 0x0040,
    #[doc = "Declared transient; not written or read by a persistent object manager."]
    TRANSIENT = 0x0080,
    #[doc = "Declared synthetic; not present in the source code."]
    SYNTHETIC = 0x1000,
    #[doc = "Declared as an element of an enum."]
    ENUM = 0x4000,
  }
}

pub(crate) trait CpDebug<'a> {
  type Output: Debug;

  fn debug(&'a self, pool: &'a ConstantPool) -> Self::Output;
}

impl<'a, T: CpDebug<'a>> CpDebug<'a> for Vec<T> {
  type Output = Vec<T::Output>;

  fn debug(&'a self, pool: &'a ConstantPool) -> Self::Output {
    self.iter().map(|v| v.debug(pool)).collect()
  }
}

#[derive(Cpref)]
struct AttributeInfo {
  #[cpref]
  attribute_name_index: u16,
  info: ByteSeq,
}

#[derive(Cpref)]
struct MethodInfo {
  access_flags: MethodInfoAccessFlags,
  #[cpref]
  name_index: u16,
  #[cpref]
  descriptor_index: u16,
  #[cpref(with = Vec<AttributeInfoDebug<'a>>)]
  attributes: Vec<AttributeInfo>,
}

#[derive(Cpref)]
struct FieldInfo {
  access_flags: FieldInfoAccessFlags,
  #[cpref]
  name_index: u16,
  #[cpref]
  descriptor_index: u16,
  #[cpref]
  attributes_count: u16,
  #[cpref(with = Vec<AttributeInfoDebug<'a>>)]
  attributes: Vec<AttributeInfo>,
}

pub(crate) struct ConstantPool(Vec<Rc<CpInfo>>);

impl Deread for ConstantPool {
  fn deread(mut r: impl Dereader) -> io::Result<Self> {
    let mut buf = Vec::with_capacity(usize::from(r.deread::<u16>()? - 1));
    for _ in 0..buf.capacity() {
      buf.push(Rc::new(r.deread()?));
    }
    Ok(Self(buf))
  }
}

impl ConstantPool {
  pub(crate) fn get(&self, index: u16) -> Option<&Rc<CpInfo>> {
    self.0.get(usize::from(index - 1))
  }
}

pub(crate) struct ClassFile {
  minor_version: u16,
  major_version: u16,
  constant_pool: ConstantPool,
  access_flags: ClassFileAccessFlags,
  this_class: u16,
  super_class: u16,
  interfaces: Vec<u16>,
  fields: Vec<FieldInfo>,
  methods: Vec<MethodInfo>,
  attributes: Vec<AttributeInfo>,
}

impl Debug for ClassFile {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    f.debug_struct("ClassFile")
      .field("minor_version", &self.minor_version)
      .field("major_version", &self.major_version)
      // .field(
      //   "constant_pool",
      //   &self
      //     .constant_pool
      //     .0
      //     .iter()
      //     .map(|cp| cp.debug(&self.constant_pool))
      //     .collect::<Vec<_>>(),
      // )
      .field("access_flags", &self.access_flags)
      .field("this_class", &self.this_class)
      .field("super_class", &self.super_class)
      .field("interfaces", &self.interfaces)
      .field(
        "fields",
        &self
          .fields
          .iter()
          .map(|v| v.debug(&self.constant_pool))
          .collect::<Vec<_>>(),
      )
      .field(
        "methods",
        &self
          .methods
          .iter()
          .map(|v| v.debug(&self.constant_pool))
          .collect::<Vec<_>>(),
      )
      .field(
        "attributes",
        &self
          .attributes
          .iter()
          .map(|v| v.debug(&self.constant_pool))
          .collect::<Vec<_>>(),
      )
      .finish_non_exhaustive()
  }
}

impl Deread for ClassFile {
  fn deread(mut r: impl Dereader) -> io::Result<Self> {
    if r.deread::<u32>()? != MAGIC {
      return Err(io::Error::new(
        io::ErrorKind::InvalidData,
        "Invalid class file",
      ));
    }

    Ok(Self {
      minor_version: r.deread()?,
      major_version: r.deread()?,
      constant_pool: r.deread()?,
      access_flags: r.deread()?,
      this_class: r.deread()?,
      super_class: r.deread()?,
      interfaces: r.deread()?,
      fields: r.deread()?,
      methods: r.deread()?,
      attributes: r.deread()?,
    })
  }
}
